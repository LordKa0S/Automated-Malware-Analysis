#!/usr/bin/env python

"""Simple HTTP Server With Upload.

This module builds on BaseHTTPServer by implementing the standard GET
and HEAD requests in a fairly straightforward manner.

"""


__version__ = "0.1"
__all__ = ["SimpleHTTPRequestHandler"]

from os.path import join, abspath, normpath
import posixpath
import BaseHTTPServer
import urllib
import cgi
import shutil
import mimetypes
import hashlib
import mysql.connector as mariadb
import re
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO


def md5(fname):
    hash_md5 = hashlib.md5()
    with open(join(abspath("uploads"), fname), "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()


def sha256(fname):
    hash_sha256 = hashlib.sha256()
    with open(join(abspath("uploads"), fname), "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_sha256.update(chunk)
    return hash_sha256.hexdigest()


class SimpleHTTPRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):

    """Simple HTTP request handler with GET/HEAD/POST commands.

    """

    server_version = "SimpleHTTPWithUpload/" + __version__

    def do_GET(self):
        """Serve a GET request."""
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        if not self.path[1:]:
            f = open("index.html")  # self.path has /
    # note that this potentially makes every file on your computer readable by the internet

            self.wfile.write(f.read())
            f.close()
        else:
            loc = self.path[1:]
            con = mariadb.connect(user='root', password='',
                                  host='localhost', database='ama')
            c = con.cursor()
            c.execute(
                'SELECT filename,sub,finished from tasks where tid=%s' % loc)
            res = c.fetchone()
            if not res:
                self.wfile.write(
                    '<html>Doesnt exist. <a href="/">Click here</a></html>')
            else:
                fname = res[0]
                sub = res[1]
                finished = res[2]
                self.wfile.write('<!DOCTYPE html>')
                self.wfile.write('<body>')
                self.wfile.write(
                    '<div>Viewing results for: %s<div><hr>' % fname)
                self.wfile.write('<div>Submitted on: %s<div><hr>' % sub)
                self.wfile.write('<div>MD5 hash:%s<div><hr>' % md5(fname))
                self.wfile.write('<div>SHA256 hash:%s<div><hr>' %
                                 sha256(fname))
                if not finished:
                    self.wfile.write(
                        '<div>Status pending. Refresh to update</div>')

    def do_POST(self):
        """Serve a POST request."""
        r, info = self.deal_post_data()
        print r, info, "by: ", self.client_address
        #f = StringIO()
        # with open("temp.html", 'w+') as f:
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        self.wfile.write('<!DOCTYPE html>')
        self.wfile.write(
            "\n<html>\n<head>\n<title>Upload Result Page</title>\n<head>")
        self.wfile.write("\n<body>\n<h2>Upload Result Page</h2>")
        self.wfile.write("<hr>")
        if r:
            self.wfile.write("\n<strong>Success:</strong>")
        else:
            self.wfile.write("\n<strong>Failed:</strong>")
        self.wfile.write(info)
        self.wfile.write("\n</body>\n</html>")
        # f.seek(0)
        #     if f:
        #         self.wfile.write(f.read())
        # f.close()

    def save_file(self, up_file):
        outpath = join(abspath("uploads"), up_file.filename)
        with open(outpath, 'wb') as fout:
            shutil.copyfileobj(up_file.file, fout, 100000)

    def copyfile(self, source, outputfile):
        """Copy all data between two file objects.

        The SOURCE argument is a file object open for reading
        (or anything with a read() method) and the DESTINATION
        argument is a file object open for writing (or
        anything with a write() method).

        The only reason for overriding this would be to change
        the block size or perhaps to replace newlines by CRLF
        -- note however that this the default server uses this
        to copy binary data as well.

        """
        shutil.copyfileobj(source, outputfile)

    def deal_post_data(self):
        form = cgi.FieldStorage(
            fp=self.rfile,
            headers=self.headers,
            environ={'REQUEST_METHOD': 'POST'})

        saved_fns = ""
        try:
            f = form['file']
            self.save_file(f)
            saved_fns = saved_fns + f.filename
            con = mariadb.connect(user='root', password='',
                                  host='localhost', database='ama')
            c = con.cursor()
            c.execute(
                'INSERT INTO tasks (filename,analysing,finished,sub) values ("%s",0,0,now())' % saved_fns)
            con.commit()
            c.execute(
                'SELECT tid from tasks where filename="%s" order by sub desc' % saved_fns)
            row = c.fetchone()
            return (True, 'File(s) "%s" upload success!. <a href="/%s">Click here to check status' % (saved_fns, row[0]))
        except IOError:
            return (False, "Can't create file to write, do you have permission to write?")


# def test(HandlerClass=SimpleHTTPRequestHandler,
#          ServerClass=BaseHTTPServer.HTTPServer):
#     BaseHTTPServer.test(HandlerClass, ServerClass)


# if __name__ == '__main__':
#     test()
def main():
    try:
        server = BaseHTTPServer.HTTPServer(
            ('', 8080), SimpleHTTPRequestHandler)
        print 'started httpserver...'
        server.serve_forever()
    except KeyboardInterrupt:
        print '^C received, shutting down server'
        server.socket.close()


if __name__ == '__main__':
    main()
